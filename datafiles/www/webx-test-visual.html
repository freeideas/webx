<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>WebX Comprehensive Test Suite</title>
    <style>
        body {
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif;
            margin: 0;
            padding: 20px;
            background: #f5f7fa;
            color: #333;
        }
        .container {
            max-width: 1200px;
            margin: 0 auto;
        }
        h1 {
            color: #2c3e50;
            text-align: center;
            margin-bottom: 30px;
            font-size: 2.5em;
        }
        .test-info {
            background: #e3f2fd;
            border: 1px solid #1976d2;
            border-radius: 8px;
            padding: 15px;
            margin-bottom: 20px;
        }
        .test-grid {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(350px, 1fr));
            gap: 20px;
            margin-bottom: 30px;
        }
        .test-card {
            background: white;
            border-radius: 8px;
            box-shadow: 0 2px 8px rgba(0,0,0,0.1);
            padding: 20px;
            transition: transform 0.2s;
        }
        .test-card:hover {
            transform: translateY(-2px);
            box-shadow: 0 4px 12px rgba(0,0,0,0.15);
        }
        .test-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 15px;
        }
        .test-title {
            font-size: 1.2em;
            font-weight: 600;
            color: #34495e;
        }
        .status {
            padding: 4px 12px;
            border-radius: 20px;
            font-size: 0.85em;
            font-weight: 500;
        }
        .status.pending {
            background: #ffd93d;
            color: #333;
        }
        .status.running {
            background: #6bcf7f;
            color: white;
            animation: pulse 1.5s infinite;
        }
        .status.success {
            background: #4caf50;
            color: white;
        }
        .status.error {
            background: #f44336;
            color: white;
        }
        @keyframes pulse {
            0% { opacity: 1; }
            50% { opacity: 0.7; }
            100% { opacity: 1; }
        }
        .test-details {
            font-size: 0.9em;
            color: #666;
            margin: 10px 0;
        }
        .test-result {
            background: #f8f9fa;
            border-radius: 4px;
            padding: 10px;
            margin-top: 10px;
            font-family: monospace;
            font-size: 0.85em;
            max-height: 200px;
            overflow-y: auto;
        }
        .test-result.error {
            background: #ffebee;
            color: #c62828;
        }
        .summary {
            background: white;
            border-radius: 8px;
            padding: 20px;
            box-shadow: 0 2px 8px rgba(0,0,0,0.1);
            margin-bottom: 20px;
        }
        .summary-stats {
            display: flex;
            justify-content: space-around;
            text-align: center;
        }
        .stat {
            padding: 10px;
        }
        .stat-value {
            font-size: 2em;
            font-weight: bold;
            margin-bottom: 5px;
        }
        .stat-label {
            color: #666;
            font-size: 0.9em;
        }
        .control-panel {
            text-align: center;
            margin: 20px 0;
        }
        button {
            background: #2196f3;
            color: white;
            border: none;
            padding: 10px 20px;
            border-radius: 4px;
            font-size: 1em;
            cursor: pointer;
            margin: 0 5px;
            transition: background 0.2s;
        }
        button:hover {
            background: #1976d2;
        }
        button:disabled {
            background: #ccc;
            cursor: not-allowed;
        }
        .timestamp {
            text-align: center;
            color: #666;
            font-size: 0.9em;
            margin-top: 20px;
        }
        .progress-bar {
            width: 100%;
            height: 4px;
            background: #e0e0e0;
            border-radius: 2px;
            overflow: hidden;
            margin-top: 10px;
        }
        .progress-fill {
            height: 100%;
            background: #2196f3;
            transition: width 0.3s ease;
        }
    </style>
</head>
<body>
    <div class="container">
        <h1>üß™ WebX Comprehensive Test Suite</h1>
        
        <div class="test-info">
            <strong>Test Configuration:</strong><br>
            Server: <span id="serverUrl">http://localhost:13102</span><br>
            Database: Using temporary in-memory database<br>
            Test APIs: httpbin.org, JSONPlaceholder, ReqRes.in
        </div>

        <div class="summary" id="summary">
            <h2>Test Summary</h2>
            <div class="summary-stats">
                <div class="stat">
                    <div class="stat-value" id="totalTests">0</div>
                    <div class="stat-label">Total Tests</div>
                </div>
                <div class="stat">
                    <div class="stat-value" id="passedTests" style="color: #4caf50;">0</div>
                    <div class="stat-label">Passed</div>
                </div>
                <div class="stat">
                    <div class="stat-value" id="failedTests" style="color: #f44336;">0</div>
                    <div class="stat-label">Failed</div>
                </div>
                <div class="stat">
                    <div class="stat-value" id="pendingTests" style="color: #ff9800;">0</div>
                    <div class="stat-label">Pending</div>
                </div>
            </div>
            <div class="progress-bar">
                <div class="progress-fill" id="progressBar" style="width: 0%"></div>
            </div>
        </div>

        <div class="control-panel">
            <button onclick="runAllTests()" id="runButton">‚ñ∂Ô∏è Run All Tests</button>
            <button onclick="clearResults()" id="clearButton">üóëÔ∏è Clear Results</button>
            <button onclick="exportResults()" id="exportButton">üì• Export Results</button>
        </div>

        <div class="test-grid" id="testGrid">
            <!-- Test cards will be dynamically inserted here -->
        </div>

        <div class="timestamp" id="timestamp"></div>
    </div>

    <script>
        // Test definitions
        const tests = [
            {
                id: 'static-file',
                title: 'Static File Serving',
                description: 'Verify that static files are served correctly',
                async run() {
                    const response = await fetch('/webx-test-visual.html');
                    if (!response.ok) throw new Error(`HTTP ${response.status}`);
                    const text = await response.text();
                    if (!text.includes('WebX Comprehensive Test Suite')) {
                        throw new Error('Page content mismatch');
                    }
                    return { status: response.status, size: text.length + ' bytes' };
                }
            },
            {
                id: 'db-write',
                title: 'Database Write (POST)',
                description: 'Test writing data to the /db endpoint',
                async run() {
                    const testData = {
                        tests: {
                            timestamp: new Date().toISOString(),
                            user: 'test-user-' + Date.now(),
                            data: { message: 'Hello from WebX test suite!' }
                        }
                    };
                    const response = await fetch('/db', {
                        method: 'POST',
                        headers: { 'Content-Type': 'application/json' },
                        body: JSON.stringify(testData)
                    });
                    if (!response.ok) throw new Error(`HTTP ${response.status}`);
                    return { status: response.status, data: testData };
                }
            },
            {
                id: 'db-merge',
                title: 'Database Merge (PUT)',
                description: 'Test merging data in the /db endpoint',
                async run() {
                    const mergeData = {
                        tests: {
                            lastUpdate: new Date().toISOString(),
                            additionalInfo: 'Merged via PUT request'
                        }
                    };
                    const response = await fetch('/db', {
                        method: 'PUT',
                        headers: { 'Content-Type': 'application/json' },
                        body: JSON.stringify(mergeData)
                    });
                    if (!response.ok) throw new Error(`HTTP ${response.status}`);
                    return { status: response.status, merged: mergeData };
                }
            },
            {
                id: 'proxy-httpbin-get',
                title: 'Proxy: HTTPBin GET',
                description: 'Test proxy with httpbin.org GET request',
                async run() {
                    const response = await fetch('/proxy', {
                        method: 'GET',
                        headers: { 'X-Target-URL': 'https://httpbin.org/get?test=webx' }
                    });
                    if (!response.ok) throw new Error(`HTTP ${response.status}`);
                    const data = await response.json();
                    if (!data.args || data.args.test !== 'webx') {
                        throw new Error('Proxy did not forward query params correctly');
                    }
                    return { status: response.status, args: data.args };
                }
            },
            {
                id: 'proxy-httpbin-post',
                title: 'Proxy: HTTPBin POST',
                description: 'Test proxy with httpbin.org POST request',
                async run() {
                    const postData = { test: 'webx-proxy', timestamp: Date.now() };
                    const response = await fetch('/proxy', {
                        method: 'POST',
                        headers: {
                            'X-Target-URL': 'https://httpbin.org/post',
                            'Content-Type': 'application/json'
                        },
                        body: JSON.stringify(postData)
                    });
                    if (!response.ok) throw new Error(`HTTP ${response.status}`);
                    const data = await response.json();
                    const receivedData = JSON.parse(data.data);
                    if (receivedData.test !== 'webx-proxy') {
                        throw new Error('Proxy did not forward POST data correctly');
                    }
                    return { status: response.status, sentData: postData };
                }
            },
            {
                id: 'proxy-jsonplaceholder',
                title: 'Proxy: JSONPlaceholder API',
                description: 'Test proxy with JSONPlaceholder fake REST API',
                async run() {
                    const response = await fetch('/proxy', {
                        method: 'GET',
                        headers: { 'X-Target-URL': 'https://jsonplaceholder.typicode.com/posts/1' }
                    });
                    if (!response.ok) throw new Error(`HTTP ${response.status}`);
                    const data = await response.json();
                    if (!data.userId || !data.title) {
                        throw new Error('Invalid response from JSONPlaceholder');
                    }
                    return { status: response.status, postId: data.id, title: data.title.substring(0, 30) + '...' };
                }
            },
            {
                id: 'proxy-reqres',
                title: 'Proxy: ReqRes API',
                description: 'Test proxy with ReqRes.in API',
                async run() {
                    const response = await fetch('/proxy', {
                        method: 'GET',
                        headers: { 'X-Target-URL': 'https://reqres.in/api/users/2' }
                    });
                    if (!response.ok) throw new Error(`HTTP ${response.status}`);
                    const data = await response.json();
                    if (!data.data || !data.data.email) {
                        throw new Error('Invalid response from ReqRes');
                    }
                    return { status: response.status, user: data.data.first_name + ' ' + data.data.last_name };
                }
            },
            {
                id: 'proxy-post-form',
                title: 'Proxy: Form Data POST',
                description: 'Test proxy with form-encoded POST data',
                async run() {
                    const formData = new URLSearchParams();
                    formData.append('name', 'WebX Test');
                    formData.append('version', '1.0');
                    
                    const response = await fetch('/proxy', {
                        method: 'POST',
                        headers: {
                            'X-Target-URL': 'https://httpbin.org/post',
                            'Content-Type': 'application/x-www-form-urlencoded'
                        },
                        body: formData.toString()
                    });
                    if (!response.ok) throw new Error(`HTTP ${response.status}`);
                    const data = await response.json();
                    if (!data.form || data.form.name !== 'WebX Test') {
                        throw new Error('Form data not forwarded correctly');
                    }
                    return { status: response.status, form: data.form };
                }
            },
            {
                id: 'cors-headers',
                title: 'CORS Headers Check',
                description: 'Verify CORS headers are properly set',
                async run() {
                    const response = await fetch('/proxy', {
                        method: 'OPTIONS',
                        headers: { 'X-Target-URL': 'https://httpbin.org/get' }
                    });
                    const corsHeaders = {
                        'Access-Control-Allow-Origin': response.headers.get('Access-Control-Allow-Origin'),
                        'Access-Control-Allow-Methods': response.headers.get('Access-Control-Allow-Methods'),
                        'Access-Control-Allow-Headers': response.headers.get('Access-Control-Allow-Headers')
                    };
                    if (!corsHeaders['Access-Control-Allow-Origin']) {
                        throw new Error('Missing CORS headers');
                    }
                    return { status: response.status, corsHeaders };
                }
            },
            {
                id: 'error-handling',
                title: 'Error Handling',
                description: 'Test proxy error handling with invalid URL',
                async run() {
                    try {
                        const response = await fetch('/proxy', {
                            method: 'GET',
                            headers: { 'X-Target-URL': 'https://invalid-domain-that-does-not-exist.com' }
                        });
                        return { status: response.status, message: 'Proxy handled invalid URL gracefully' };
                    } catch (error) {
                        return { message: 'Error caught as expected', error: error.message };
                    }
                }
            }
        ];

        // Test state
        let testResults = {};
        let isRunning = false;

        // Initialize test cards
        function initializeTests() {
            const grid = document.getElementById('testGrid');
            grid.innerHTML = '';
            
            tests.forEach(test => {
                const card = document.createElement('div');
                card.className = 'test-card';
                card.id = `test-${test.id}`;
                card.innerHTML = `
                    <div class="test-header">
                        <div class="test-title">${test.title}</div>
                        <div class="status pending" id="status-${test.id}">Pending</div>
                    </div>
                    <div class="test-details">${test.description}</div>
                    <div class="test-result" id="result-${test.id}" style="display: none;"></div>
                `;
                grid.appendChild(card);
            });
            
            updateSummary();
        }

        // Run a single test
        async function runTest(test) {
            const statusEl = document.getElementById(`status-${test.id}`);
            const resultEl = document.getElementById(`result-${test.id}`);
            
            statusEl.className = 'status running';
            statusEl.textContent = 'Running...';
            resultEl.style.display = 'none';
            
            const startTime = Date.now();
            
            try {
                const result = await test.run();
                const duration = Date.now() - startTime;
                
                testResults[test.id] = { success: true, result, duration };
                
                statusEl.className = 'status success';
                statusEl.textContent = 'Success';
                resultEl.className = 'test-result';
                resultEl.innerHTML = `<strong>‚úÖ Passed (${duration}ms)</strong><br>${JSON.stringify(result, null, 2)}`;
                resultEl.style.display = 'block';
            } catch (error) {
                const duration = Date.now() - startTime;
                
                testResults[test.id] = { success: false, error: error.message, duration };
                
                statusEl.className = 'status error';
                statusEl.textContent = 'Failed';
                resultEl.className = 'test-result error';
                resultEl.innerHTML = `<strong>‚ùå Failed (${duration}ms)</strong><br>${error.message}`;
                resultEl.style.display = 'block';
            }
            
            updateSummary();
        }

        // Run all tests
        async function runAllTests() {
            if (isRunning) return;
            
            isRunning = true;
            document.getElementById('runButton').disabled = true;
            testResults = {};
            
            for (const test of tests) {
                await runTest(test);
                await new Promise(resolve => setTimeout(resolve, 100)); // Small delay between tests
            }
            
            isRunning = false;
            document.getElementById('runButton').disabled = false;
            
            // Update timestamp
            document.getElementById('timestamp').textContent = 
                `Tests completed at ${new Date().toLocaleString()}`;
            
            // Save results to database
            await saveResultsToDatabase();
        }

        // Update summary statistics
        function updateSummary() {
            const total = tests.length;
            const results = Object.values(testResults);
            const passed = results.filter(r => r.success).length;
            const failed = results.filter(r => !r.success).length;
            const pending = total - results.length;
            
            document.getElementById('totalTests').textContent = total;
            document.getElementById('passedTests').textContent = passed;
            document.getElementById('failedTests').textContent = failed;
            document.getElementById('pendingTests').textContent = pending;
            
            const progress = (results.length / total) * 100;
            document.getElementById('progressBar').style.width = `${progress}%`;
        }

        // Clear all results
        function clearResults() {
            testResults = {};
            initializeTests();
            document.getElementById('timestamp').textContent = '';
        }

        // Export results as JSON
        function exportResults() {
            const exportData = {
                timestamp: new Date().toISOString(),
                results: testResults,
                summary: {
                    total: tests.length,
                    passed: Object.values(testResults).filter(r => r.success).length,
                    failed: Object.values(testResults).filter(r => !r.success).length
                }
            };
            
            const blob = new Blob([JSON.stringify(exportData, null, 2)], { type: 'application/json' });
            const url = URL.createObjectURL(blob);
            const a = document.createElement('a');
            a.href = url;
            a.download = `webx-test-results-${Date.now()}.json`;
            a.click();
            URL.revokeObjectURL(url);
        }

        // Save results to database
        async function saveResultsToDatabase() {
            try {
                const dbData = {
                    testRuns: {
                        [Date.now()]: {
                            timestamp: new Date().toISOString(),
                            results: testResults,
                            summary: {
                                total: tests.length,
                                passed: Object.values(testResults).filter(r => r.success).length,
                                failed: Object.values(testResults).filter(r => !r.success).length
                            }
                        }
                    }
                };
                
                await fetch('/db', {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify(dbData)
                });
            } catch (error) {
                console.error('Failed to save results to database:', error);
            }
        }

        // Initialize on load
        document.addEventListener('DOMContentLoaded', () => {
            initializeTests();
        });

        // Auto-run tests if URL has ?autorun
        if (window.location.search.includes('autorun')) {
            window.addEventListener('load', () => {
                setTimeout(runAllTests, 1000);
            });
        }
    </script>
</body>
</html>